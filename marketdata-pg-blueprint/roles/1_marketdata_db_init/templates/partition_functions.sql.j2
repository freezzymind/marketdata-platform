-- Partition maintenance functions.
-- Used by a microservice that connects as `partition_manager` and calls these functions.
-- Functions are SECURITY DEFINER and owned by the parent table owner (postgres).

-- Create a daily partition for a partitioned parent table
CREATE OR REPLACE FUNCTION {{ exchange }}.create_daily_partition(p_parent regclass, p_day date)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = {{ exchange }}, pg_catalog
AS $$
BEGIN
  -- Allow-list only our parent tables
  IF p_parent NOT IN (
    '{{ candles }}'::regclass,
    '{{ orderbooks }}'::regclass,
    '{{ trades }}'::regclass
  ) THEN
    RAISE EXCEPTION 'Partitioning is not allowed for %', p_parent;
  END IF;

  -- Create partition name parent_YYYYMMDD (e.g., btc_trades_20260103)
  EXECUTE format(
    'CREATE TABLE IF NOT EXISTS %I.%I_%s PARTITION OF %s FOR VALUES FROM (%L) TO (%L)',
    split_part(p_parent::text, '.', 1),
    split_part(p_parent::text, '.', 2),
    to_char(p_day, 'YYYYMMDD'),
    p_parent,
    p_day::timestamp,
    (p_day + 1)::timestamp
  );
END
$$;

-- Drop partitions older than the specified day (strictly before p_before)
CREATE OR REPLACE FUNCTION {{ exchange }}.drop_partitions_older_than(p_parent regclass, p_before date)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = {{ exchange }}, pg_catalog
AS $$
DECLARE
  r record;
  dropped int := 0;
  suffix text;
  part_day date;
BEGIN
  -- Allow-list only our parent tables
  IF p_parent NOT IN (
    '{{ candles }}'::regclass,
    '{{ orderbooks }}'::regclass,
    '{{ trades }}'::regclass
  ) THEN
    RAISE EXCEPTION 'Dropping is not allowed for %', p_parent;
  END IF;

  -- Find all partitions for the parent and drop by suffix date
  FOR r IN
    SELECT n.nspname, c.relname
    FROM pg_inherits i
    JOIN pg_class c ON c.oid = i.inhrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE i.inhparent = p_parent
  LOOP
    suffix := substring(r.relname from '([0-9]{8})$');
    IF suffix IS NULL THEN
      CONTINUE;
    END IF;

    part_day := to_date(suffix, 'YYYYMMDD');
    IF part_day < p_before THEN
      EXECUTE format('DROP TABLE IF EXISTS %I.%I', r.nspname, r.relname);
      dropped := dropped + 1;
    END IF;
  END LOOP;

  RETURN dropped;
END
$$;

-- Lock down function access
REVOKE ALL ON FUNCTION {{ exchange }}.create_daily_partition(regclass, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION {{ exchange }}.drop_partitions_older_than(regclass, date) FROM PUBLIC;

-- Allow partition_manager to call them
GRANT EXECUTE ON FUNCTION {{ exchange }}.create_daily_partition(regclass, date) TO partition_manager;
GRANT EXECUTE ON FUNCTION {{ exchange }}.drop_partitions_older_than(regclass, date) TO partition_manager;
