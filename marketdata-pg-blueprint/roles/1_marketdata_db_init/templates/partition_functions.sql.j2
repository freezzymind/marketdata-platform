-- Partition maintenance functions.
-- Used by a microservice that connects as `partition_manager` and calls these functions.
-- Functions are SECURITY DEFINER and owned by postgres (or whoever owns parent tables).

-- Create a daily partition for a partitioned parent table
CREATE OR REPLACE FUNCTION {{ exchange }}.create_daily_partition(p_parent regclass, p_day date)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = {{ exchange }}, pg_catalog
AS $$
DECLARE
  v_schema text;
  v_rel    text;
BEGIN
  -- Allow-list only our parent tables
  IF p_parent NOT IN (
    '{{ candles }}'::regclass,
    '{{ orderbooks }}'::regclass,
    '{{ trades }}'::regclass
  ) THEN
    RAISE EXCEPTION 'Partitioning is not allowed for %', p_parent;
  END IF;

  -- Resolve schema/table name from regclass OID (robust)
  SELECT n.nspname, c.relname
    INTO v_schema, v_rel
  FROM pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE c.oid = p_parent;

  IF v_schema IS NULL OR v_rel IS NULL THEN
    RAISE EXCEPTION 'Parent table not found for %', p_parent;
  END IF;

  -- Create partition: <schema>.<table>_YYYYMMDD
  EXECUTE format(
    'CREATE TABLE IF NOT EXISTS %I.%I_%s PARTITION OF %I.%I FOR VALUES FROM (%L) TO (%L)',
    v_schema,
    v_rel,
    to_char(p_day, 'YYYYMMDD'),
    v_schema,
    v_rel,
    p_day::timestamp,
    (p_day + 1)::timestamp
  );
END
$$;

-- Drop partitions older than the specified day (strictly before p_before)
CREATE OR REPLACE FUNCTION {{ exchange }}.drop_partitions_older_than(p_parent regclass, p_before date)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = {{ exchange }}, pg_catalog
AS $$
DECLARE
  r record;
  dropped int := 0;
  suffix text;
  part_day date;
BEGIN
  -- Allow-list only our parent tables
  IF p_parent NOT IN (
    '{{ candles }}'::regclass,
    '{{ orderbooks }}'::regclass,
    '{{ trades }}'::regclass
  ) THEN
    RAISE EXCEPTION 'Dropping is not allowed for %', p_parent;
  END IF;

  FOR r IN
    SELECT n.nspname, c.relname
    FROM pg_inherits i
    JOIN pg_class c ON c.oid = i.inhrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE i.inhparent = p_parent
  LOOP
    suffix := substring(r.relname from '([0-9]{8})$');
    IF suffix IS NULL THEN
      CONTINUE;
    END IF;

    part_day := to_date(suffix, 'YYYYMMDD');
    IF part_day < p_before THEN
      EXECUTE format('DROP TABLE IF EXISTS %I.%I', r.nspname, r.relname);
      dropped := dropped + 1;
    END IF;
  END LOOP;

  RETURN dropped;
END
$$;

-- Lock down function access
REVOKE ALL ON FUNCTION {{ exchange }}.create_daily_partition(regclass, date) FROM PUBLIC;
REVOKE ALL ON FUNCTION {{ exchange }}.drop_partitions_older_than(regclass, date) FROM PUBLIC;

-- Allow partition_manager to call them
GRANT EXECUTE ON FUNCTION {{ exchange }}.create_daily_partition(regclass, date) TO partition_manager;
GRANT EXECUTE ON FUNCTION {{ exchange }}.drop_partitions_older_than(regclass, date) TO partition_manager;
